{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Smart Beta Strategy\n",
    "\n",
    "# set up like financial planner. Use monte carlo to see possible futures. \n",
    "\n",
    "from quantopian.pipeline import Pipeline, CustomFactor\n",
    "from quantopian.algorithm import attach_pipeline, pipeline_output\n",
    "from quantopian.pipeline.data.builtin import USEquityPricing\n",
    "from quantopian.pipeline.factors import SimpleMovingAverage, Returns\n",
    "from quantopian.pipeline.classifiers.morningstar import Sector\n",
    "from quantopian.pipeline.filters.morningstar import Q500US, Q1500US\n",
    "from quantopian.pipeline.data import morningstar\n",
    "import pandas as pd\n",
    "import math\n",
    "import numpy as np\n",
    " \n",
    "def initialize(context):\n",
    "    \"\"\"\n",
    "    Called once at the start of the algorithm.\n",
    "    \"\"\"   \n",
    "    set_commission(commission.PerTrade(cost=0.00))\n",
    "    set_commission(commission.PerShare(cost=0.00, min_trade_cost=0.00))\n",
    "                   \n",
    "    # Rebalance at begining of every month, 1 hour after market open.\n",
    "   \n",
    "    schedule_function(my_rebalance, date_rules.month_start(), time_rules.market_open(hours=1))\n",
    "     \n",
    "    # Record tracking variables at the end of each day.\n",
    "    schedule_function(my_record_vars, date_rules.month_start(), time_rules.market_close())\n",
    "    \n",
    "    context.num_per_sector = 2 #number of stocks to go long/short per sector\n",
    "    context.month_interval = 1 #monthly frequency of rebalance\n",
    "    context.long_target = 1.0\n",
    "    context.short_target = 1.0 - context.long_target\n",
    "    \n",
    "    context.long_turnover = 0\n",
    "    context.short_turnover = 0\n",
    "    context.month = context.month_interval\n",
    "     \n",
    "    # Create our dynamic stock selector.\n",
    "    attach_pipeline(make_pipeline(), 'my_pipeline')     \n",
    "         \n",
    "def make_pipeline():\n",
    "    pipe =  Pipeline(\n",
    "        columns={'Close': USEquityPricing.close.latest,\n",
    "                 '10_Day': SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=10),\n",
    "                 '50_Day': SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=50),\n",
    "                 'M_Cap': morningstar.valuation.market_cap.latest,\n",
    "                 'Sector': Sector(),\n",
    "                 'Div': morningstar.valuation_ratios.dividend_yield.latest,\n",
    "                 'PE': morningstar.valuation_ratios.pe_ratio.latest,\n",
    "                 'Mom': Momentum(),\n",
    "                 'Vol': Volatility_Daily_Annual()\n",
    "                },\n",
    "    screen = Q1500US()\n",
    "    )\n",
    "    return pipe\n",
    " \n",
    "class Volatility_Daily_Annual(CustomFactor): \n",
    "    \n",
    "    inputs = [USEquityPricing.close]  \n",
    "    window_length = 120  \n",
    "    \n",
    "    def compute(self, today, assets, out, close):  \n",
    "        \n",
    "        # [0:-1] is needed to remove last close since diff is one element shorter \n",
    "        daily_returns = np.diff(close, axis = 0) / close[0:-1] \n",
    "        out[:] = daily_returns.std(axis = 0) * math.sqrt(252)\n",
    "        \n",
    "class Momentum(CustomFactor):\n",
    "    \n",
    "    inputs = [USEquityPricing.close]\n",
    "    window_length = 20\n",
    "    \n",
    "    def compute(self, today, assets, out, close):       \n",
    "        out[:] = close[-1] / close[0]  \n",
    "    \n",
    "def good_bad(stocks,m):\n",
    "    stocks = stocks[np.isfinite(stocks['M_Cap'])] #remove stocks with unknown market cap\n",
    "    stocks = stocks[np.isfinite(stocks['Mom'])] #remove stocks with unknown momentum\n",
    "    nulls = stocks.isnull()\n",
    "    stocks.loc[nulls.Div,['Div']] = 0 #set NaN dividend yields to 0\n",
    "    stocks.loc[nulls.Div,['PE']] = 1000 #set NaN P/E ratios to 1000\n",
    "    stocks = stocks[np.isfinite(stocks['Div'])] #remove stocks that still have unknown dividend yield\n",
    "    stocks = stocks[np.isfinite(stocks['PE'])] #remove stocks that still have unknown P/E ratios\n",
    "    m_cap = stocks.M_Cap.quantile(.5) #find 50th percentile of market cap\n",
    "    pe = stocks.PE.quantile(.5) #find 50th percentile of P/E ratio\n",
    "    \n",
    "    good = stocks[(stocks.M_Cap < m_cap) & (stocks.PE < pe)] #go long on the lower left quadrant of size and value\n",
    "    if len(good) >= m*2: #divide up remaining stocks based on top 50% of dividend yield\n",
    "        div = good.Div.quantile(.5)\n",
    "        good = good[good.Div > div]\n",
    "    if len(good) >= m*2: #divide up remaining stocks based on bottom 50% of price volatility\n",
    "        vol = good.Vol.quantile(.5)\n",
    "        good = good[(good.Vol < vol)]\n",
    "    good = good.sort_values(by='M_Cap', ascending=False).iloc[0:m] #get largest remaining stocks (tendency for mid-cap)\n",
    "    \n",
    "    bad = stocks[(stocks.M_Cap > m_cap) & (stocks.PE > pe)] #go short on upper right quadrant of size and value\n",
    "    if len(bad) >= m*2: #divide up remaining stocks based on bottom 50% of dividend yield\n",
    "        div = bad.Div.quantile(.5)\n",
    "        bad = bad[(bad.Div <= div)]    \n",
    "    bad = bad.sort_values(by='Vol', ascending=False).iloc[0:m] #get most volatile stocks left\n",
    "    \n",
    "    return good, bad\n",
    " \n",
    "def weighting(stocks):    \n",
    "    stocks = stocks.sort_values(by='Mom', ascending=False)\n",
    "    mom = stocks['Mom'].values.tolist()\n",
    "    mom = [x ** -10.0 for x in mom] \n",
    "    momentum_total = sum(mom)\n",
    "    mom = [x/momentum_total for x in mom]  \n",
    "    stocks['Weight'] = mom\n",
    "    return stocks\n",
    " \n",
    "def before_trading_start(context, data):\n",
    "    \"\"\"\n",
    "    Called every day before market open.\n",
    "    \"\"\"\n",
    "    stocks = pipeline_output('my_pipeline')\n",
    "    m = context.num_per_sector\n",
    "    \n",
    "    [ag, ab] = good_bad(stocks[(stocks.Sector == 101)],m)\n",
    "    [bg, bb] = good_bad(stocks[(stocks.Sector == 102)],m)\n",
    "    [cg, cb] = good_bad(stocks[(stocks.Sector == 103)],m)\n",
    "    [dg, db] = good_bad(stocks[(stocks.Sector == 104)],m)\n",
    "    [eg, eb] = good_bad(stocks[(stocks.Sector == 205)],m)\n",
    "    [fg, fb] = good_bad(stocks[(stocks.Sector == 206)],m)\n",
    "    [gg, gb] = good_bad(stocks[(stocks.Sector == 207)],m)\n",
    "    [hg, hb] = good_bad(stocks[(stocks.Sector == 309)],m)\n",
    "    [ig, ib] = good_bad(stocks[(stocks.Sector == 310)],m)\n",
    "    [jg, jb] = good_bad(stocks[(stocks.Sector == 311)],m)\n",
    "    \n",
    "    good = pd.concat([ag,bg,cg,dg,eg,fg,gg,hg,ig,jg])\n",
    "    bad = pd.concat([ab,bb,cb,db,eb,fb,gb,hb,ib,jb])\n",
    "    \n",
    "    #Inverse momentum for shorts\n",
    "    mom = bad['Mom'].values.tolist()\n",
    "    mom = [1/x for x in mom]   \n",
    "    bad['Mom'] = mom    \n",
    "    \n",
    "    context.bad = weighting(bad) \n",
    "    context.good = weighting(good) \n",
    " \n",
    "def my_rebalance(context,data):\n",
    "    \"\"\"\n",
    "    Execute orders according to our schedule_function() timing. \n",
    "    \"\"\"\n",
    "    if context.month != context.month_interval:\n",
    "        context.month += 1\n",
    "        return\n",
    "    context.month = 1\n",
    "    \n",
    "    good_weight = context.good['Weight'].values.tolist()        \n",
    "    good_stocks = context.good.index.tolist()\n",
    "    bad_weight = context.bad['Weight'].values.tolist()        \n",
    "    bad_stocks = context.bad.index.tolist()\n",
    "    \n",
    "    for security in context.portfolio.positions:\n",
    "        if security not in good_stocks and security not in bad_stocks and data.can_trade(security):\n",
    "            order_target_percent(security,0)\n",
    "            shares = context.portfolio.positions[security].amount\n",
    "            if shares < 0:\n",
    "                context.short_turnover += 1 \n",
    "            else:    \n",
    "                context.long_turnover += 1 \n",
    "            \n",
    "    #Order longs            \n",
    "    n = len(good_stocks)\n",
    "    for x in range(0, n):  \n",
    "        if data.can_trade(good_stocks[x]):\n",
    "            order_target_percent(good_stocks[x],good_weight[x]*context.long_target)\n",
    "            \n",
    "    #Order shorts           \n",
    "    n = len(bad_stocks)        \n",
    "    for x in range(0, n):  \n",
    "        if data.can_trade(bad_stocks[x]):\n",
    "            order_target_percent(bad_stocks[x],-1*bad_weight[x]*context.short_target)               \n",
    "        \n",
    "def my_record_vars(context, data):\n",
    "    \"\"\"\n",
    "    Plot variables at the end of each day.\n",
    "    \"\"\"\n",
    "    long_count = 0\n",
    "    short_count = 0\n",
    " \n",
    "    for position in context.portfolio.positions.itervalues():\n",
    "        if position.amount > 0:\n",
    "            long_count += 1\n",
    "        if position.amount < 0:\n",
    "            short_count += 1\n",
    "            \n",
    "    # Plot the counts\n",
    "    record(short_churn = context.short_turnover, long_churn = context.long_turnover, num_long=long_count, num_short=short_count, leverage=context.account.leverage)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
